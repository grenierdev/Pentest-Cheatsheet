# OS Recon

## Linux

### Manual
```sh
# Whoami
$ id
# List all users
$ cat /etc/passwd
# What is the name of host
$ hostname
# OS information
$ uname -a
$ cat /etc/*-release
# Running processes and services
$ ps auxww --forest
# Network informations
$ route
$ ip addr
$ netstat -ie
# Listening services and ports
$ systemctl list-units --type=service
$ netstat -natup
# <see below for netstat-less>
# Inspect firewall rules
$ sudo iptables -L
# List CRON
$ ls -lah /etc/cron*
$ cat /etc/crontab
# Startup server
$ ls -lah /etc/systemd/system/
# List installed packages, applications
$ dpkg -l
# Find writable files and directories
$ find / -writable 2>/dev/null
# Find newly modified files
$ find / -mtime -1 2>/dev/null
# Find file with SUID
$ find / -perm -u=s -type f 2>/dev/null
$ find / -perm -u=s -type f 2>/dev/null -exec echo {} \; -exec {} --version \; -exec echo "" \;
# Find interesting files
$ find / -name password.txt 2>/dev/null
# List volumes
$ cat /etc/fstab
$ mount
$ lsblk
# List device drivers
$ lsmod
$ /sbin/modinfo floppy
```

### unix-privesc-check

Site: http://pentestmonkey.net/tools/audit/unix-privesc-check

> Unix-privesc-checker is a script that runs on Unix systems (tested on Solaris 9, HPUX 11, Various Linuxes, FreeBSD 6.2).  It tries to find misconfigurations that could allow local unprivilged users to escalate privileges to other users or to access local apps (e.g. databases).

### netstat-less port enum

```sh
awk 'function hextodec(str,ret,n,i,k,c){
    ret = 0
    n = length(str)
    for (i = 1; i <= n; i++) {
        c = tolower(substr(str, i, 1))
        k = index("123456789abcdef", c)
        ret = ret * 16 + k
    }
    return ret
}
function getIP(str,ret){
    ret=hextodec(substr(str,index(str,":")-2,2)); 
    for (i=5; i>0; i-=2) {
        ret = ret"."hextodec(substr(str,i,2))
    }
    ret = ret":"hextodec(substr(str,index(str,":")+1,4))
    return ret
} 
NR > 1 {{if(NR==2)print "Local - Remote";local=getIP($2);remote=getIP($3)}{print local" - "remote}}' /proc/net/tcp
```

## Windows

### Manual
```sh
# Whoami
> whoami /user
> whoami /groups
> whoami /priv
> echo %USERDOMAIN%
> echo %USERNAME%
> echo %USERPROFILE%
> net user michael
# List all user
> net user
# OS information
> systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"
# Environmment variable
> set
# Disks
> wmic logicaldisk get caption,description,providername
# Running services
> tasklist /SVC
> wmic service get startname,name,startmode,pathname
> Get-WmiObject win32_service | Format-Table Name, State, StartMode, StartName, PathName
> ps
# Find interesting files
> dir /S password.txt
# Check UAC
> reg query HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System
# Network information
> ipconfig /all
> route print
> netstat -rn
# Listening services and ports
> netstat -ano
# Inspect firewall
> netsh advfirewall show currentprofile
> netsh advfirewall firewall show rule name=all
# List CRON
> schtasks /query /fo LIST /v
# List update, patches
> wmic product get name, version, vendor
> wmic qfe get Caption, Description, HotFixID, InstalledOn
# Find writable files and directories
> accesschk.exe -uws "Everyone" "C:\Program Files"
> Get-ChildItem "C:\Program Files" -Recurse | Get-ACL | ?{$_.AccessToString -match "Everyone\sAllow\s\sModify"}
# List volumes
> mountvol
# List device drivers
> driverquery /v
> powershell driverquery.exe /v /fo csv | ConvertFrom-CSV | Select-Object ‘Display Name’, ‘Start Mode’, Path
> Get-WmiObject Win32_PnPSignedDriver | Select-Object DeviceName, DriverVersion, Manufacturer | Where-Object {$_.DeviceName -like "*VMware*"}
```

### windows-privesc-check

Site: https://github.com/pentestmonkey/windows-privesc-check

> Windows-privesc-check is standalone executable that runs on Windows systems. It tries to find misconfigurations that could allow local unprivileged users to escalate privileges to other users or to access local apps (e.g. databases).

### Windows Interpreted Location

Windows will search each "interpreted location" in an attempt to find a valid executable path.

For example, imagine that we have a service stored in a path such as C:\Program Files\My Program\My Service\service.exe. If the service path is stored unquoted, whenever Windows starts the service it will attempt to run an executable from the following paths:

```
C:\Program.exe
C:\Program Files\My.exe
C:\Program Files\My Program\My.exe
C:\Program Files\My Program\My service\service.exe
```

## Service / Autorun App / CRON

Service or autorun app that are writable can be swapped with a malicious binary.